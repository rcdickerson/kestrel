
Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.
  UNSATISFIABLE ASSERTION Assert at sketch.sk:121 (2)

*** Rejected
    [0;31m[1751564789.2850 - ERROR] [SKETCH] Sketch Not Resolved Error:   UNSATISFIABLE ASSERTION Assert at sketch.sk:121 (2)

*** Rejected
The sketch could not be resolved.[0m
    [0;32m[1751564789.3030 - DEBUG] [SKETCH] stack trace written to file: /home/rob/.sketch/tmp/stacktrace.txt[0m
    [0;32m[1751564789.3040 - DEBUG] Backend solver input file at /home/rob/.sketch/tmp/sketch.sk/input0.tmp[0m
Failed to solve sketch.

Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_choice
Computed alignment by local loop counting.
  UNSATISFIABLE ASSERTION Assert at sketch.sk:121 (2)

*** Rejected
    [0;31m[1751564790.7780 - ERROR] [SKETCH] Sketch Not Resolved Error:   UNSATISFIABLE ASSERTION Assert at sketch.sk:121 (2)

*** Rejected
The sketch could not be resolved.[0m
    [0;32m[1751564790.7850 - DEBUG] [SKETCH] stack trace written to file: /home/rob/.sketch/tmp/stacktrace.txt[0m
    [0;32m[1751564790.7851 - DEBUG] Backend solver input file at /home/rob/.sketch/tmp/sketch.sk/input0.tmp[0m
Failed to solve sketch.

Beginning Iteration
-------------------
add_unrolls: true
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.
  UNSATISFIABLE ASSERTION Assert at sketch.sk:273 (2)

*** Rejected
    [0;31m[1751564793.4180 - ERROR] [SKETCH] Sketch Not Resolved Error:   UNSATISFIABLE ASSERTION Assert at sketch.sk:273 (2)

*** Rejected
The sketch could not be resolved.[0m
    [0;32m[1751564793.4250 - DEBUG] [SKETCH] stack trace written to file: /home/rob/.sketch/tmp/stacktrace.txt[0m
    [0;32m[1751564793.4251 - DEBUG] Backend solver input file at /home/rob/.sketch/tmp/sketch.sk/input0.tmp[0m
Failed to solve sketch.

Beginning Iteration
-------------------
add_unrolls: true
depth: 1
cost function: optimize_choice
Computed alignment by local loop counting.


*** Rejected
    [0;31m[1751564796.0540 - ERROR] [SKETCH] Sketch Not Resolved Error: 

*** Rejected
The sketch could not be resolved.[0m
    [0;32m[1751564796.0610 - DEBUG] [SKETCH] stack trace written to file: /home/rob/.sketch/tmp/stacktrace.txt[0m
    [0;32m[1751564796.0611 - DEBUG] Backend solver input file at /home/rob/.sketch/tmp/sketch.sk/input0.tmp[0m
Failed to solve sketch.

Beginning Iteration
-------------------
add_unrolls: false
depth: 2
cost function: optimize_structure
Computed alignment by local loop counting.
Writing Daikon to /home/rob/code/kestrel/.kestrel-work/daikon_output.c...
Done
Compiling Daikon output...
Running Kvasir...
==55116== kvasir-5.8.18, C/C++ Language Front-End for Daikon with DynComp comparability analysis tool.
==55116== Copyright (C) 2007-2022, University of Washington CSE PLSE Group
==55116== Using Valgrind-3.19.0.Fjalar and LibVEX; rerun with -h for copyright info
==55116== Command: /home/rob/code/kestrel/.kestrel-work/daikon_output
==55116== 
==55117== 
==55117== For lists of detected and suppressed errors, rerun with: -s
==55117== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55118== 
==55118== For lists of detected and suppressed errors, rerun with: -s
==55118== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55119== 
==55119== For lists of detected and suppressed errors, rerun with: -s
==55119== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55120== 
==55120== For lists of detected and suppressed errors, rerun with: -s
==55120== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55121== 
==55121== For lists of detected and suppressed errors, rerun with: -s
==55121== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55122== 
==55122== For lists of detected and suppressed errors, rerun with: -s
==55122== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55123== 
==55123== For lists of detected and suppressed errors, rerun with: -s
==55123== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55124== 
==55124== For lists of detected and suppressed errors, rerun with: -s
==55124== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55125== 
==55125== For lists of detected and suppressed errors, rerun with: -s
==55125== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55126== 
==55126== For lists of detected and suppressed errors, rerun with: -s
==55126== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55127== 
==55127== For lists of detected and suppressed errors, rerun with: -s
==55127== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55128== 
==55128== For lists of detected and suppressed errors, rerun with: -s
==55128== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55129== 
==55129== For lists of detected and suppressed errors, rerun with: -s
==55129== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55130== 
==55130== For lists of detected and suppressed errors, rerun with: -s
==55130== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55131== 
==55131== For lists of detected and suppressed errors, rerun with: -s
==55131== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55132== 
==55132== For lists of detected and suppressed errors, rerun with: -s
==55132== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55133== 
==55133== For lists of detected and suppressed errors, rerun with: -s
==55133== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55134== 
==55134== For lists of detected and suppressed errors, rerun with: -s
==55134== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55135== 
==55135== For lists of detected and suppressed errors, rerun with: -s
==55135== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55136== 
==55136== For lists of detected and suppressed errors, rerun with: -s
==55136== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55116== 
==55116== For lists of detected and suppressed errors, rerun with: -s
==55116== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Running Daikon...
houdafny.dfy(23,2): Warning: assume statement has no {:axiom} annotation
   |
23 |   assume l_size == l_list.Length;
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(24,2): Warning: assume statement has no {:axiom} annotation
   |
24 |   assume r_size == r_list.Length;
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(25,2): Warning: assume statement has no {:axiom} annotation
   |
25 |   assume l_list != r_list;
   |   ^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(26,2): Warning: assume statement has no {:axiom} annotation
   |
26 |   assume (l_size == r_size) && ((l_size >= 1) && forall arr_eq_n: nat :: (((arr_eq_n < l_list.Length) && (arr_eq_n < r_list.Length)) ==> (l_list[arr_eq_n] == r_list[arr_eq_n])));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(51,6): Warning: assume statement has no {:axiom} annotation
   |
51 |       assume ((!(l_list[l_j - 1] < l_list[l_j])) || (l_cmp < 10)) && (((!(l_list[l_j - 1] == l_list[l_j])) || (l_cmp == 10)) && ((!(l_list[l_j - 1] > l_list[l_j])) || (l_cmp > 10)));
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(99,8): Warning: assume statement has no {:axiom} annotation
   |
99 |         assume !(r_j > r_i);
   |         ^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(103,8): Warning: assume statement has no {:axiom} annotation
    |
103 |         assume ((!(l_list[l_j - 1] < l_list[l_j])) || (l_cmp < 10)) && (((!(l_list[l_j - 1] == l_list[l_j])) || (l_cmp == 10)) && ((!(l_list[l_j - 1] > l_list[l_j])) || (l_cmp > 10)));
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(122,8): Warning: assume statement has no {:axiom} annotation
    |
122 |         assume !(l_j > l_i);
    |         ^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(147,6): Warning: assume statement has no {:axiom} annotation
    |
147 |       assume !(r_i < r_size);
    |       ^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(159,10): Warning: assume statement has no {:axiom} annotation
    |
159 |           assume ((!(l_list[l_j - 1] < l_list[l_j])) || (l_cmp < 10)) && (((!(l_list[l_j - 1] == l_list[l_j])) || (l_cmp == 10)) && ((!(l_list[l_j - 1] > l_list[l_j])) || (l_cmp > 10)));
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(180,6): Warning: assume statement has no {:axiom} annotation
    |
180 |       assume !(l_i < l_size);
    |       ^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 1 verified, 0 errors


Aligned Product Program
-----------------------

function compare(i: int, j: int): int

function havoc_1(l_size: int, r_j: int, r_size: int, r_i: int, l_i: int, l_j: int, r_list: array<int>, l_list: array<int>): int

function havoc_3(l_size: int, r_j: int, r_size: int, r_i: int, l_i: int, l_j: int, r_list: array<int>, l_list: array<int>): int

function havoc_5(l_size: int, r_j: int, r_size: int, r_i: int, l_i: int, l_j: int, r_list: array<int>, l_list: array<int>): int

function choice_n_2(l_size: int, r_j: int, r_size: int, r_i: int, l_i: int, l_j: int, r_list: array<int>, l_list: array<int>): int

function choice_n_4(l_size: int, r_j: int, r_size: int, r_i: int, l_i: int, l_j: int, r_list: array<int>, l_list: array<int>): int

function choice_n_6(l_size: int, r_j: int, l_j: int, l_cmp: int, r_size: int, r_i: int, l_i: int, r_list: array<int>, l_list: array<int>): int {
  if (9 < l_cmp) then 11 else 9
 }

method Product(l_size: int, l_list: array<int>, r_size: int, r_list: array<int>)
  decreases *
  modifies l_list
  modifies r_list
{
  assume l_size == l_list.Length;
  assume r_size == r_list.Length;
  assume l_list != r_list;
  assume (l_size == r_size) && ((l_size >= 1) && forall arr_eq_n: nat :: (((arr_eq_n < l_list.Length) && (arr_eq_n < r_list.Length)) ==> (l_list[arr_eq_n] == r_list[arr_eq_n])));
  var l_i: int;
  l_i := 0;
  var l_j: int;
  l_j := 0;
  var r_i: int;
  r_i := 0;
  var r_j: int;
  r_j := 0;
  while ((l_i < l_size) && (r_i < r_size))
    decreases *
    invariant l_i == r_i
    invariant forall arr_eq_n: nat :: (((arr_eq_n < l_list.Length) && (arr_eq_n < r_list.Length)) ==> (l_list[arr_eq_n] == r_list[arr_eq_n]))
  {
    l_j := (l_size - 1);
    r_j := (r_size - 1);
    while ((l_j > l_i) && (r_j > r_i))
      decreases *
      invariant l_j < l_size
      invariant l_j == r_j
      invariant forall arr_eq_n: nat :: (((arr_eq_n < l_list.Length) && (arr_eq_n < r_list.Length)) ==> (l_list[arr_eq_n] == r_list[arr_eq_n]))
    {
      var l_cmp: int;
      assert true;
      l_cmp := havoc_5(l_size, r_j, r_size, r_i, l_i, l_j, r_list, l_list);
      assume ((!(l_list[l_j - 1] < l_list[l_j])) || (l_cmp < 10)) && (((!(l_list[l_j - 1] == l_list[l_j])) || (l_cmp == 10)) && ((!(l_list[l_j - 1] > l_list[l_j])) || (l_cmp > 10)));
      var r_cmp: int;
      var n_6: int := choice_n_6(l_size, r_j, l_j, l_cmp, r_size, r_i, l_i, r_list, l_list);
      assert (n_6 == 9) || ((n_6 == 10) || (n_6 == 11));
      r_cmp := n_6;
      if ((l_cmp > 10) && (r_cmp > 10)) {
        var l_val: int;
        l_val := l_list[l_j];
        var l_prev_val: int;
        l_prev_val := l_list[l_j - 1];
        l_list[l_j] := l_prev_val;
        l_list[l_j - 1] := l_val;
        var r_val: int;
        r_val := r_list[r_j];
        var r_prev_val: int;
        r_prev_val := r_list[r_j - 1];
        r_list[r_j] := r_prev_val;
        r_list[r_j - 1] := r_val;
      } else {
        if ((l_cmp > 10) && (!(r_cmp > 10))) {
          var l_val: int;
          l_val := l_list[l_j];
          var l_prev_val: int;
          l_prev_val := l_list[l_j - 1];
          l_list[l_j] := l_prev_val;
          l_list[l_j - 1] := l_val;
        } else {
          if ((!(l_cmp > 10)) && (r_cmp > 10)) {
            var r_val: int;
            r_val := r_list[r_j];
            var r_prev_val: int;
            r_prev_val := r_list[r_j - 1];
            r_list[r_j] := r_prev_val;
            r_list[r_j - 1] := r_val;
          } else {
          }
        }
      }
      l_j := (l_j - 1);
      r_j := (r_j - 1);
    }
    if (l_j > l_i) {
      while (l_j > l_i)
        decreases *
        invariant l_j < l_size
        invariant l_j == r_j
        invariant forall arr_eq_n: nat :: (((arr_eq_n < l_list.Length) && (arr_eq_n < r_list.Length)) ==> (l_list[arr_eq_n] == r_list[arr_eq_n]))
      {
        assume !(r_j > r_i);
        var l_cmp: int;
        assert true;
        l_cmp := havoc_3(l_size, r_j, r_size, r_i, l_i, l_j, r_list, l_list);
        assume ((!(l_list[l_j - 1] < l_list[l_j])) || (l_cmp < 10)) && (((!(l_list[l_j - 1] == l_list[l_j])) || (l_cmp == 10)) && ((!(l_list[l_j - 1] > l_list[l_j])) || (l_cmp > 10)));
        if (l_cmp > 10) {
          var l_val: int;
          l_val := l_list[l_j];
          var l_prev_val: int;
          l_prev_val := l_list[l_j - 1];
          l_list[l_j] := l_prev_val;
          l_list[l_j - 1] := l_val;
        }
        l_j := (l_j - 1);
      }
    }
    if (r_j > r_i) {
      while (r_j > r_i)
        decreases *
        invariant l_j < l_size
        invariant l_j == r_j
        invariant forall arr_eq_n: nat :: (((arr_eq_n < l_list.Length) && (arr_eq_n < r_list.Length)) ==> (l_list[arr_eq_n] == r_list[arr_eq_n]))
      {
        assume !(l_j > l_i);
        var r_cmp: int;
        var n_4: int := choice_n_4(l_size, r_j, r_size, r_i, l_i, l_j, r_list, l_list);
        assert (n_4 == 9) || ((n_4 == 10) || (n_4 == 11));
        r_cmp := n_4;
        if (r_cmp > 10) {
          var r_val: int;
          r_val := r_list[r_j];
          var r_prev_val: int;
          r_prev_val := r_list[r_j - 1];
          r_list[r_j] := r_prev_val;
          r_list[r_j - 1] := r_val;
        }
        r_j := (r_j - 1);
      }
    }
    l_i := (l_i + 1);
    r_i := (r_i + 1);
  }
  if (l_i < l_size) {
    while (l_i < l_size)
      decreases *
      invariant l_i == r_i
      invariant forall arr_eq_n: nat :: (((arr_eq_n < l_list.Length) && (arr_eq_n < r_list.Length)) ==> (l_list[arr_eq_n] == r_list[arr_eq_n]))
    {
      assume !(r_i < r_size);
      l_j := (l_size - 1);
      if (l_j > l_i) {
        while (l_j > l_i)
          decreases *
          invariant l_j < l_size
          invariant l_j == r_j
          invariant forall arr_eq_n: nat :: (((arr_eq_n < l_list.Length) && (arr_eq_n < r_list.Length)) ==> (l_list[arr_eq_n] == r_list[arr_eq_n]))
        {
          var l_cmp: int;
          assert true;
          l_cmp := havoc_1(l_size, r_j, r_size, r_i, l_i, l_j, r_list, l_list);
          assume ((!(l_list[l_j - 1] < l_list[l_j])) || (l_cmp < 10)) && (((!(l_list[l_j - 1] == l_list[l_j])) || (l_cmp == 10)) && ((!(l_list[l_j - 1] > l_list[l_j])) || (l_cmp > 10)));
          if (l_cmp > 10) {
            var l_val: int;
            l_val := l_list[l_j];
            var l_prev_val: int;
            l_prev_val := l_list[l_j - 1];
            l_list[l_j] := l_prev_val;
            l_list[l_j - 1] := l_val;
          }
          l_j := (l_j - 1);
        }
      }
      l_i := (l_i + 1);
    }
  }
  if (r_i < r_size) {
    while (r_i < r_size)
      decreases *
      invariant l_i == r_i
      invariant forall arr_eq_n: nat :: (((arr_eq_n < l_list.Length) && (arr_eq_n < r_list.Length)) ==> (l_list[arr_eq_n] == r_list[arr_eq_n]))
    {
      assume !(l_i < l_size);
      r_j := (r_size - 1);
      if (r_j > r_i) {
        while (r_j > r_i)
          decreases *
          invariant l_j < l_size
          invariant l_j == r_j
          invariant forall arr_eq_n: nat :: (((arr_eq_n < l_list.Length) && (arr_eq_n < r_list.Length)) ==> (l_list[arr_eq_n] == r_list[arr_eq_n]))
        {
          var r_cmp: int;
          var n_2: int := choice_n_2(l_size, r_j, r_size, r_i, l_i, l_j, r_list, l_list);
          assert (n_2 == 9) || ((n_2 == 10) || (n_2 == 11));
          r_cmp := n_2;
          if (r_cmp > 10) {
            var r_val: int;
            r_val := r_list[r_j];
            var r_prev_val: int;
            r_prev_val := r_list[r_j - 1];
            r_list[r_j] := r_prev_val;
            r_list[r_j - 1] := r_val;
          }
          r_j := (r_j - 1);
        }
      }
      r_i := (r_i + 1);
    }
  }
  assert forall arr_eq_n: nat :: (((arr_eq_n < l_list.Length) && (arr_eq_n < r_list.Length)) ==> (l_list[arr_eq_n] == r_list[arr_eq_n]));
}


Per-Task Times (ms)
-------------------
insert-elaenia-specs: 0
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 19
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 1
solve-sketch: 1450
elaenia-invars: 0
houdafny: 0
compound_task: 1472
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 19
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 1
solve-sketch: 1448
elaenia-invars: 0
houdafny: 0
compound_task: 1470
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 22
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 2
solve-sketch: 2614
elaenia-invars: 0
houdafny: 0
compound_task: 2641
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 19
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 2
solve-sketch: 2612
elaenia-invars: 0
houdafny: 0
compound_task: 2635
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 19
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 1
solve-sketch: 15549
elaenia-invars: 2206
houdafny: 1403
repeat_range: 27403
write-dafny: 0
print-info: 0


Extraction Settings
-------------------
Max AST Depth: 2
Loop unrolling: false
Cost function: structure
Max AST Depth: 2

Elaenia completed in 27404ms
Verified: true
