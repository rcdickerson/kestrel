
Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.
  UNSATISFIABLE ASSERTION Assert at sketch.sk:97 (2)

*** Rejected
    [0;31m[1751565633.8800 - ERROR] [SKETCH] Sketch Not Resolved Error:   UNSATISFIABLE ASSERTION Assert at sketch.sk:97 (2)

*** Rejected
The sketch could not be resolved.[0m
    [0;32m[1751565633.8870 - DEBUG] [SKETCH] stack trace written to file: /home/rob/.sketch/tmp/stacktrace.txt[0m
    [0;32m[1751565633.8871 - DEBUG] Backend solver input file at /home/rob/.sketch/tmp/sketch.sk/input0.tmp[0m
Failed to solve sketch.

Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_choice
Computed alignment by local loop counting.
  UNSATISFIABLE ASSERTION Assert at sketch.sk:97 (2)

*** Rejected
    [0;31m[1751565635.2810 - ERROR] [SKETCH] Sketch Not Resolved Error:   UNSATISFIABLE ASSERTION Assert at sketch.sk:97 (2)

*** Rejected
The sketch could not be resolved.[0m
    [0;32m[1751565635.2880 - DEBUG] [SKETCH] stack trace written to file: /home/rob/.sketch/tmp/stacktrace.txt[0m
    [0;32m[1751565635.2881 - DEBUG] Backend solver input file at /home/rob/.sketch/tmp/sketch.sk/input0.tmp[0m
Failed to solve sketch.

Beginning Iteration
-------------------
add_unrolls: true
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.


*** Rejected
    [0;31m[1751565636.7240 - ERROR] [SKETCH] Sketch Not Resolved Error: 

*** Rejected
The sketch could not be resolved.[0m
    [0;32m[1751565636.7310 - DEBUG] [SKETCH] stack trace written to file: /home/rob/.sketch/tmp/stacktrace.txt[0m
    [0;32m[1751565636.7311 - DEBUG] Backend solver input file at /home/rob/.sketch/tmp/sketch.sk/input0.tmp[0m
Failed to solve sketch.

Beginning Iteration
-------------------
add_unrolls: true
depth: 1
cost function: optimize_choice
Computed alignment by local loop counting.


*** Rejected
    [0;31m[1751565638.2300 - ERROR] [SKETCH] Sketch Not Resolved Error: 

*** Rejected
The sketch could not be resolved.[0m
    [0;32m[1751565638.2370 - DEBUG] [SKETCH] stack trace written to file: /home/rob/.sketch/tmp/stacktrace.txt[0m
    [0;32m[1751565638.2371 - DEBUG] Backend solver input file at /home/rob/.sketch/tmp/sketch.sk/input0.tmp[0m
Failed to solve sketch.

Beginning Iteration
-------------------
add_unrolls: false
depth: 2
cost function: optimize_structure
Computed alignment by local loop counting.
Writing Daikon to /home/rob/code/kestrel/.kestrel-work/daikon_output.c...
Done
Compiling Daikon output...
Running Kvasir...
==57611== kvasir-5.8.18, C/C++ Language Front-End for Daikon with DynComp comparability analysis tool.
==57611== Copyright (C) 2007-2022, University of Washington CSE PLSE Group
==57611== Using Valgrind-3.19.0.Fjalar and LibVEX; rerun with -h for copyright info
==57611== Command: /home/rob/code/kestrel/.kestrel-work/daikon_output
==57611== 
==57612== 
==57612== For lists of detected and suppressed errors, rerun with: -s
==57612== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57613== 
==57613== For lists of detected and suppressed errors, rerun with: -s
==57613== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57614== 
==57614== For lists of detected and suppressed errors, rerun with: -s
==57614== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57615== 
==57615== For lists of detected and suppressed errors, rerun with: -s
==57615== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57616== 
==57616== For lists of detected and suppressed errors, rerun with: -s
==57616== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57617== 
==57617== For lists of detected and suppressed errors, rerun with: -s
==57617== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57618== 
==57618== For lists of detected and suppressed errors, rerun with: -s
==57618== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57619== 
==57619== For lists of detected and suppressed errors, rerun with: -s
==57619== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57620== 
==57620== For lists of detected and suppressed errors, rerun with: -s
==57620== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57622== 
==57622== For lists of detected and suppressed errors, rerun with: -s
==57622== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57624== 
==57624== For lists of detected and suppressed errors, rerun with: -s
==57624== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57625== 
==57625== For lists of detected and suppressed errors, rerun with: -s
==57625== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57626== 
==57626== For lists of detected and suppressed errors, rerun with: -s
==57626== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57627== 
==57627== For lists of detected and suppressed errors, rerun with: -s
==57627== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57628== 
==57628== For lists of detected and suppressed errors, rerun with: -s
==57628== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57629== 
==57629== For lists of detected and suppressed errors, rerun with: -s
==57629== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57630== 
==57630== For lists of detected and suppressed errors, rerun with: -s
==57630== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57631== 
==57631== For lists of detected and suppressed errors, rerun with: -s
==57631== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57632== 
==57632== For lists of detected and suppressed errors, rerun with: -s
==57632== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57633== 
==57633== For lists of detected and suppressed errors, rerun with: -s
==57633== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==57611== 
==57611== For lists of detected and suppressed errors, rerun with: -s
==57611== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Running Daikon...
houdafny.dfy(19,2): Warning: assume statement has no {:axiom} annotation
   |
19 |   assume (l_size + 1) == l_a.Length;
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(20,2): Warning: assume statement has no {:axiom} annotation
   |
20 |   assume (r_size + 1) == r_a.Length;
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(21,2): Warning: assume statement has no {:axiom} annotation
   |
21 |   assume l_a != r_a;
   |   ^^^^^^^^^^^^^^^^^^

houdafny.dfy(22,2): Warning: assume statement has no {:axiom} annotation
   |
22 |   assume (l_size == r_size) && ((l_size > 0) && forall arr_eq_n: nat :: (((arr_eq_n < l_a.Length) && (arr_eq_n < r_a.Length)) ==> (l_a[arr_eq_n] == r_a[arr_eq_n])));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(57,4): Warning: assume statement has no {:axiom} annotation
   |
57 |     assume ((!(l_max < l_a[l_i])) || (l_cmp < 10)) && (((!(l_max == l_a[l_i])) || (l_cmp == 10)) && ((!(l_max > l_a[l_i])) || (l_cmp > 10)));
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(109,6): Warning: assume statement has no {:axiom} annotation
    |
109 |       assume !(r_j <= r_size);
    |       ^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(113,6): Warning: assume statement has no {:axiom} annotation
    |
113 |       assume ((!(l_max < l_a[l_i])) || (l_cmp < 10)) && (((!(l_max == l_a[l_i])) || (l_cmp == 10)) && ((!(l_max > l_a[l_i])) || (l_cmp > 10)));
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(125,6): Warning: assume statement has no {:axiom} annotation
    |
125 |       assume !(l_i <= l_size);
    |       ^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 1 verified, 0 errors


Aligned Product Program
-----------------------

function compare(i: int, j: int): int

function havoc_1(r_t: int, r_size: int, l_i: int, l_max: int, r_maxi: int, r_max: int, l_size: int, l_maxi: int, r_j: int, l_a: array<int>, r_a: array<int>): int

function havoc_3(r_t: int, r_size: int, l_i: int, l_max: int, r_maxi: int, r_max: int, l_size: int, l_maxi: int, r_j: int, l_a: array<int>, r_a: array<int>): int

function choice_n_2(r_t: int, r_size: int, l_i: int, l_max: int, r_maxi: int, r_max: int, l_size: int, l_maxi: int, r_j: int, l_a: array<int>, r_a: array<int>): int

function choice_n_4(r_t: int, l_cmp: int, r_size: int, l_i: int, l_max: int, r_maxi: int, r_max: int, l_size: int, l_maxi: int, r_j: int, l_a: array<int>, r_a: array<int>): int {
  if (l_cmp < 10) then 9 else 11
 }

method Product(l_size: int, l_a: array<int>, r_size: int, r_a: array<int>)
  decreases *
  modifies l_a
  modifies r_a
{
  assume (l_size + 1) == l_a.Length;
  assume (r_size + 1) == r_a.Length;
  assume l_a != r_a;
  assume (l_size == r_size) && ((l_size > 0) && forall arr_eq_n: nat :: (((arr_eq_n < l_a.Length) && (arr_eq_n < r_a.Length)) ==> (l_a[arr_eq_n] == r_a[arr_eq_n])));
  var l_max: int;
  l_max := l_a[0];
  var l_maxi: int;
  l_maxi := 0;
  var l_i: int;
  l_i := 0;
  var r_j: int;
  r_j := 0;
  var r_max: int;
  r_max := 0;
  var r_maxi: int;
  r_maxi := 0;
  var r_t: int;
  r_t := 0;
  while ((l_i <= l_size) && (r_j <= r_size))
    decreases *
    invariant l_i == r_j
    invariant (0 <= l_i) && (l_i <= (l_size + 1))
    invariant (0 <= r_j) && (r_j <= (r_size + 1))
    invariant (0 <= l_maxi) && ((l_maxi <= l_i) && (l_maxi <= l_size))
    invariant (0 <= r_maxi) && ((r_maxi <= r_j) && (r_maxi <= r_size))
    invariant (!((0 < r_j) && (r_j <= r_size))) || (r_max == r_a[r_maxi])
    invariant l_max == l_a[l_maxi]
    invariant (!(r_j == (r_size + 1))) || (l_max == r_a[r_size])
    invariant (!(r_j == (r_size + 1))) || (l_a[l_maxi] == r_a[r_size])
    invariant l_maxi == r_maxi
    invariant (!(r_j == (r_size + 1))) || forall i: int :: ((!((i >= 0) && ((i <= l_size) && ((i != r_maxi) && (i != r_size))))) || (l_a[i] == r_a[i]))
    invariant (!(r_j <= r_size)) || forall arr_eq_n: nat :: (((arr_eq_n < l_a.Length) && (arr_eq_n < r_a.Length)) ==> (l_a[arr_eq_n] == r_a[arr_eq_n]))
    invariant (!(l_i > 0)) || (l_max == r_max)
    invariant (!(r_j == (r_size + 1))) || (l_a[l_size] == r_a[r_maxi])
  {
    var l_cmp: int;
    assert true;
    l_cmp := havoc_3(r_t, r_size, l_i, l_max, r_maxi, r_max, l_size, l_maxi, r_j, l_a, r_a);
    assume ((!(l_max < l_a[l_i])) || (l_cmp < 10)) && (((!(l_max == l_a[l_i])) || (l_cmp == 10)) && ((!(l_max > l_a[l_i])) || (l_cmp > 10)));
    if (r_j == 0) {
      r_max := r_a[0];
      r_maxi := 0;
    }
    var r_cmp: int;
    var n_4: int := choice_n_4(r_t, l_cmp, r_size, l_i, l_max, r_maxi, r_max, l_size, l_maxi, r_j, l_a, r_a);
    assert (n_4 == 9) || ((n_4 == 10) || (n_4 == 11));
    r_cmp := n_4;
    if ((l_cmp < 10) && (r_cmp < 10)) {
      l_max := l_a[l_i];
      l_maxi := l_i;
      r_max := r_a[r_j];
      r_maxi := r_j;
    } else {
      if ((l_cmp < 10) && (!(r_cmp < 10))) {
        l_max := l_a[l_i];
        l_maxi := l_i;
      } else {
        if ((!(l_cmp < 10)) && (r_cmp < 10)) {
          r_max := r_a[r_j];
          r_maxi := r_j;
        } else {
        }
      }
    }
    l_i := (l_i + 1);
    if (r_j == r_size) {
      r_t := r_a[r_size];
      r_a[r_size] := r_max;
      r_a[r_maxi] := r_t;
    }
    r_j := (r_j + 1);
  }
  if (l_i <= l_size) {
    while (l_i <= l_size)
      decreases *
      invariant l_i == r_j
      invariant (0 <= l_i) && (l_i <= (l_size + 1))
      invariant (0 <= r_j) && (r_j <= (r_size + 1))
      invariant (0 <= l_maxi) && ((l_maxi <= l_i) && (l_maxi <= l_size))
      invariant (0 <= r_maxi) && ((r_maxi <= r_j) && (r_maxi <= r_size))
      invariant (!((0 < r_j) && (r_j <= r_size))) || (r_max == r_a[r_maxi])
      invariant l_max == l_a[l_maxi]
      invariant (!(r_j == (r_size + 1))) || (l_max == r_a[r_size])
      invariant (!(r_j == (r_size + 1))) || (l_a[l_maxi] == r_a[r_size])
      invariant l_maxi == r_maxi
      invariant (!(r_j == (r_size + 1))) || forall i: int :: ((!((i >= 0) && ((i <= l_size) && ((i != r_maxi) && (i != r_size))))) || (l_a[i] == r_a[i]))
      invariant (!(r_j <= r_size)) || forall arr_eq_n: nat :: (((arr_eq_n < l_a.Length) && (arr_eq_n < r_a.Length)) ==> (l_a[arr_eq_n] == r_a[arr_eq_n]))
      invariant (!(l_i > 0)) || (l_max == r_max)
      invariant (!(r_j == (r_size + 1))) || (l_a[l_size] == r_a[r_maxi])
    {
      assume !(r_j <= r_size);
      var l_cmp: int;
      assert true;
      l_cmp := havoc_1(r_t, r_size, l_i, l_max, r_maxi, r_max, l_size, l_maxi, r_j, l_a, r_a);
      assume ((!(l_max < l_a[l_i])) || (l_cmp < 10)) && (((!(l_max == l_a[l_i])) || (l_cmp == 10)) && ((!(l_max > l_a[l_i])) || (l_cmp > 10)));
      if (l_cmp < 10) {
        l_max := l_a[l_i];
        l_maxi := l_i;
      }
      l_i := (l_i + 1);
    }
  }
  if (r_j <= r_size) {
    while (r_j <= r_size)
      decreases *
    {
      assume !(l_i <= l_size);
      if (r_j == 0) {
        r_max := r_a[0];
        r_maxi := 0;
      }
      var r_cmp: int;
      var n_2: int := choice_n_2(r_t, r_size, l_i, l_max, r_maxi, r_max, l_size, l_maxi, r_j, l_a, r_a);
      assert (n_2 == 9) || ((n_2 == 10) || (n_2 == 11));
      r_cmp := n_2;
      if (r_cmp < 10) {
        r_max := r_a[r_j];
        r_maxi := r_j;
      }
      if (r_j == r_size) {
        r_t := r_a[r_size];
        r_a[r_size] := r_max;
        r_a[r_maxi] := r_t;
      }
      r_j := (r_j + 1);
    }
  }
  var l_t: int;
  l_t := l_a[l_size];
  l_a[l_size] := l_max;
  l_a[l_maxi] := l_t;
  assert forall arr_eq_n: nat :: (((arr_eq_n < l_a.Length) && (arr_eq_n < r_a.Length)) ==> (l_a[arr_eq_n] == r_a[arr_eq_n]));
}


Per-Task Times (ms)
-------------------
insert-elaenia-specs: 0
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 18
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 1384
elaenia-invars: 0
houdafny: 0
compound_task: 1403
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 18
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 1379
elaenia-invars: 0
houdafny: 0
compound_task: 1400
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 18
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 1
solve-sketch: 1433
elaenia-invars: 0
houdafny: 0
compound_task: 1453
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 20
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 1
solve-sketch: 1475
elaenia-invars: 0
houdafny: 0
compound_task: 1499
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 19
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 1175
elaenia-invars: 2177
houdafny: 1443
repeat_range: 10575
write-dafny: 1
print-info: 0


Extraction Settings
-------------------
Max AST Depth: 2
Loop unrolling: false
Cost function: structure
Max AST Depth: 2

Elaenia completed in 10576ms
Verified: true
