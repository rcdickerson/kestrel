
Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.
  UNSATISFIABLE ASSERTION Assert at sketch.sk:67 (2)

*** Rejected
    [0;31m[1751564867.6930 - ERROR] [SKETCH] Sketch Not Resolved Error:   UNSATISFIABLE ASSERTION Assert at sketch.sk:67 (2)

*** Rejected
The sketch could not be resolved.[0m
    [0;32m[1751564867.6990 - DEBUG] [SKETCH] stack trace written to file: /home/rob/.sketch/tmp/stacktrace.txt[0m
    [0;32m[1751564867.6991 - DEBUG] Backend solver input file at /home/rob/.sketch/tmp/sketch.sk/input0.tmp[0m
Failed to solve sketch.

Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_choice
Computed alignment by local loop counting.
  UNSATISFIABLE ASSERTION Assert at sketch.sk:67 (2)

*** Rejected
    [0;31m[1751564869.0420 - ERROR] [SKETCH] Sketch Not Resolved Error:   UNSATISFIABLE ASSERTION Assert at sketch.sk:67 (2)

*** Rejected
The sketch could not be resolved.[0m
    [0;32m[1751564869.0480 - DEBUG] [SKETCH] stack trace written to file: /home/rob/.sketch/tmp/stacktrace.txt[0m
    [0;32m[1751564869.0481 - DEBUG] Backend solver input file at /home/rob/.sketch/tmp/sketch.sk/input0.tmp[0m
Failed to solve sketch.

Beginning Iteration
-------------------
add_unrolls: true
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.
Writing Daikon to /home/rob/code/kestrel/.kestrel-work/daikon_output.c...
Done
Compiling Daikon output...
Running Kvasir...
==55851== kvasir-5.8.18, C/C++ Language Front-End for Daikon with DynComp comparability analysis tool.
==55851== Copyright (C) 2007-2022, University of Washington CSE PLSE Group
==55851== Using Valgrind-3.19.0.Fjalar and LibVEX; rerun with -h for copyright info
==55851== Command: /home/rob/code/kestrel/.kestrel-work/daikon_output
==55851== 
==55852== 
==55852== For lists of detected and suppressed errors, rerun with: -s
==55852== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55853== 
==55853== For lists of detected and suppressed errors, rerun with: -s
==55853== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55854== 
==55854== For lists of detected and suppressed errors, rerun with: -s
==55854== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55855== 
==55855== For lists of detected and suppressed errors, rerun with: -s
==55855== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55856== 
==55856== For lists of detected and suppressed errors, rerun with: -s
==55856== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55857== 
==55857== For lists of detected and suppressed errors, rerun with: -s
==55857== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55858== 
==55858== For lists of detected and suppressed errors, rerun with: -s
==55858== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55859== 
==55859== For lists of detected and suppressed errors, rerun with: -s
==55859== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55860== 
==55860== For lists of detected and suppressed errors, rerun with: -s
==55860== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55861== 
==55861== For lists of detected and suppressed errors, rerun with: -s
==55861== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55862== 
==55862== For lists of detected and suppressed errors, rerun with: -s
==55862== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55863== 
==55863== For lists of detected and suppressed errors, rerun with: -s
==55863== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55864== 
==55864== For lists of detected and suppressed errors, rerun with: -s
==55864== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55865== 
==55865== For lists of detected and suppressed errors, rerun with: -s
==55865== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55866== 
==55866== For lists of detected and suppressed errors, rerun with: -s
==55866== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55867== 
==55867== For lists of detected and suppressed errors, rerun with: -s
==55867== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55870== 
==55870== For lists of detected and suppressed errors, rerun with: -s
==55870== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55871== 
==55871== For lists of detected and suppressed errors, rerun with: -s
==55871== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55872== 
==55872== For lists of detected and suppressed errors, rerun with: -s
==55872== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55873== 
==55873== For lists of detected and suppressed errors, rerun with: -s
==55873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==55851== 
==55851== For lists of detected and suppressed errors, rerun with: -s
==55851== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Running Daikon...
houdafny.dfy(21,2): Warning: assume statement has no {:axiom} annotation
   |
21 |   assume (l_N == r_N) && (l_N > 0);
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(26,2): Warning: assume statement has no {:axiom} annotation
   |
26 |   assume (0 <= l_x) && (l_x < 50);
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(51,4): Warning: assume statement has no {:axiom} annotation
   |
51 |     assume (0 <= l_r) && (l_r < 100);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(66,6): Warning: assume statement has no {:axiom} annotation
   |
66 |       assume !(r_i <= r_N);
   |       ^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(69,6): Warning: assume statement has no {:axiom} annotation
   |
69 |       assume (0 <= l_r) && (l_r < 100);
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(78,6): Warning: assume statement has no {:axiom} annotation
   |
78 |       assume !(l_i <= l_N);
   |       ^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 1 verified, 0 errors


Aligned Product Program
-----------------------

function randB(max: int): int

function havoc_1(r_N: int, l_x: int, l_N: int): int

function havoc_2(r_r: int, r_N: int, l_x: int, r_x: int, l_r: int, l_i: int, r_i: int, l_N: int): int

function havoc_4(r_r: int, r_N: int, l_x: int, r_x: int, l_r: int, l_i: int, r_i: int, l_N: int): int

function choice_n_5(r_r: int, r_N: int, l_x: int, r_x: int, l_r: int, l_i: int, r_i: int, l_N: int): int {
  l_r
 }

function choice_n_3(r_r: int, r_N: int, l_x: int, r_x: int, l_r: int, l_i: int, r_i: int, l_N: int): int {
  l_x
 }

method Product(l_N: int, r_N: int)
  decreases *
{
  assume (l_N == r_N) && (l_N > 0);
  var l_x: int;
  l_x := 0;
  assert true;
  l_x := havoc_1(r_N, l_x, l_N);
  assume (0 <= l_x) && (l_x < 50);
  var l_i: int;
  l_i := 1;
  var l_r: int;
  l_r := 0;
  var r_x: int;
  r_x := 0;
  var r_i: int;
  r_i := 0;
  var r_r: int;
  r_r := 0;
  if (r_i <= r_N) {
    var n_3: int := choice_n_3(r_r, r_N, l_x, r_x, l_r, l_i, r_i, l_N);
    assert (0 <= n_3) && (n_3 < 100);
    r_r := n_3;
    r_x := (r_x + r_r);
    r_i := (r_i + 1);
  }
  while ((l_i <= l_N) && (r_i <= r_N))
    decreases *
    invariant l_x == r_x
    invariant l_i == r_i
  {
    assert true;
    l_r := havoc_4(r_r, r_N, l_x, r_x, l_r, l_i, r_i, l_N);
    assume (0 <= l_r) && (l_r < 100);
    l_x := (l_x + l_r);
    l_i := (l_i + 1);
    var n_5: int := choice_n_5(r_r, r_N, l_x, r_x, l_r, l_i, r_i, l_N);
    assert (0 <= n_5) && (n_5 < 100);
    r_r := n_5;
    r_x := (r_x + r_r);
    r_i := (r_i + 1);
  }
  if (l_i <= l_N) {
    while (l_i <= l_N)
      decreases *
      invariant l_x == r_x
      invariant l_i == r_i
    {
      assume !(r_i <= r_N);
      assert true;
      l_r := havoc_2(r_r, r_N, l_x, r_x, l_r, l_i, r_i, l_N);
      assume (0 <= l_r) && (l_r < 100);
      l_x := (l_x + l_r);
      l_i := (l_i + 1);
    }
  }
  if (r_i <= r_N) {
    while (r_i <= r_N)
      decreases *
    {
      assume !(l_i <= l_N);
      var n_3: int := choice_n_3(r_r, r_N, l_x, r_x, l_r, l_i, r_i, l_N);
      assert (0 <= n_3) && (n_3 < 100);
      r_r := n_3;
      r_x := (r_x + r_r);
      r_i := (r_i + 1);
    }
  }
  assert l_x == r_x;
}


Per-Task Times (ms)
-------------------
insert-elaenia-specs: 0
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 2
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 1348
elaenia-invars: 0
houdafny: 0
compound_task: 1351
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 2
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 1351
elaenia-invars: 0
houdafny: 0
compound_task: 1354
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 9
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 2
solve-sketch: 1420
elaenia-invars: 2169
houdafny: 1107
repeat_range: 7415
write-dafny: 0
print-info: 0


Extraction Settings
-------------------
Max AST Depth: 1
Loop unrolling: true
Cost function: structure
Max AST Depth: 1

Elaenia completed in 7416ms
Verified: true
