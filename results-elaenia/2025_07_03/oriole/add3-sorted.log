
Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.
WARNING: Foralls are unsupported! Treating as true.
WARNING: Foralls are unsupported! Treating as true.
WARNING: Foralls are unsupported! Treating as true.
WARNING: Foralls are unsupported! Treating as true.
WARNING: Foralls are unsupported! Treating as true.
Writing Daikon to /home/rob/code/kestrel/.kestrel-work/daikon_output.c...
Done
Compiling Daikon output...
Running Kvasir...
==47492== kvasir-5.8.18, C/C++ Language Front-End for Daikon with DynComp comparability analysis tool.
==47492== Copyright (C) 2007-2022, University of Washington CSE PLSE Group
==47492== Using Valgrind-3.19.0.Fjalar and LibVEX; rerun with -h for copyright info
==47492== Command: /home/rob/code/kestrel/.kestrel-work/daikon_output
==47492== 
==47493== 
==47493== For lists of detected and suppressed errors, rerun with: -s
==47493== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47494== 
==47494== For lists of detected and suppressed errors, rerun with: -s
==47494== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47495== 
==47495== For lists of detected and suppressed errors, rerun with: -s
==47495== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47496== 
==47496== For lists of detected and suppressed errors, rerun with: -s
==47496== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47497== 
==47497== For lists of detected and suppressed errors, rerun with: -s
==47497== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47498== 
==47498== For lists of detected and suppressed errors, rerun with: -s
==47498== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47499== 
==47499== For lists of detected and suppressed errors, rerun with: -s
==47499== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47500== 
==47500== For lists of detected and suppressed errors, rerun with: -s
==47500== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47501== 
==47501== For lists of detected and suppressed errors, rerun with: -s
==47501== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47502== 
==47502== For lists of detected and suppressed errors, rerun with: -s
==47502== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47503== 
==47503== For lists of detected and suppressed errors, rerun with: -s
==47503== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47504== 
==47504== For lists of detected and suppressed errors, rerun with: -s
==47504== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47505== 
==47505== For lists of detected and suppressed errors, rerun with: -s
==47505== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47506== 
==47506== For lists of detected and suppressed errors, rerun with: -s
==47506== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47507== 
==47507== For lists of detected and suppressed errors, rerun with: -s
==47507== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47508== 
==47508== For lists of detected and suppressed errors, rerun with: -s
==47508== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47509== 
==47509== For lists of detected and suppressed errors, rerun with: -s
==47509== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47510== 
==47510== For lists of detected and suppressed errors, rerun with: -s
==47510== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47511== 
==47511== For lists of detected and suppressed errors, rerun with: -s
==47511== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47512== 
==47512== For lists of detected and suppressed errors, rerun with: -s
==47512== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47492== 
==47492== For lists of detected and suppressed errors, rerun with: -s
==47492== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Running Daikon...
houdafny.dfy(21,2): Warning: assume statement has no {:axiom} annotation
   |
21 |   assume (l_list_in == r_list_in) && ((l_length == r_length) && (forall i: int, j: int, a: int, x: int :: ((!(i == j)) || (lst_read(lst_store(a, i, x), j) == x)) && forall i: int, j: int, a: int, x: int :: ((!(i != j)) || (lst_read(lst_store(a, i, x), j) == lst_read(a, j)))));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(25,2): Warning: assume statement has no {:axiom} annotation
   |
25 |   assume forall val: int :: (lst_contains(l_list_in, val) == lst_contains(l_list, val)) && forall i: int, j: int :: ((!(i < j)) || (lst_read(l_list, i) <= lst_read(l_list, j)));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(57,6): Warning: assume statement has no {:axiom} annotation
   |
57 |       assume !(r_i < r_length);
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(72,6): Warning: assume statement has no {:axiom} annotation
   |
72 |       assume !(l_i < l_length);
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 1 verified, 0 errors


Aligned Product Program
-----------------------

function lst_contains(list: int, value: int): int

function lst_read(list: int, index: int): int

function lst_store(list: int, index: int, value: int): int

function shuffle(list: int): int

function sort(list: int): int

function havoc_1(l_length: int, r_length: int): int

function choice_n_2(l_length: int, l_list: int, l_i: int, r_length: int): int {
  l_list
 }

method Product(l_list_in: int, l_length: int, r_list_in: int, r_length: int)
  decreases *
{
  assume (l_list_in == r_list_in) && ((l_length == r_length) && (forall i: int, j: int, a: int, x: int :: ((!(i == j)) || (lst_read(lst_store(a, i, x), j) == x)) && forall i: int, j: int, a: int, x: int :: ((!(i != j)) || (lst_read(lst_store(a, i, x), j) == lst_read(a, j)))));
  var l_list: int;
  assert true;
  l_list := havoc_1(l_length, r_length);
  assume forall val: int :: (lst_contains(l_list_in, val) == lst_contains(l_list, val)) && forall i: int, j: int :: ((!(i < j)) || (lst_read(l_list, i) <= lst_read(l_list, j)));
  var l_i: int;
  l_i := 0;
  var r_list: int;
  var n_2: int := choice_n_2(l_length, l_list, l_i, r_length);
  assert forall val: int :: (lst_contains(r_list_in, val) == lst_contains(n_2, val));
  r_list := n_2;
  var r_i: int;
  r_i := 0;
  var r_val_i: int;
  r_val_i := 0;
  while ((l_i < l_length) && (r_i < r_length))
    decreases *
    invariant l_i == r_i
    invariant l_list == r_list
  {
    var l_val_i: int;
    l_val_i := lst_read(l_list, l_i);
    var l_updated: int;
    l_updated := lst_store(l_list, l_i, l_val_i + 3);
    l_list := l_updated;
    l_i := (l_i + 1);
    r_val_i := lst_read(r_list, r_i);
    var r_updated: int;
    r_updated := lst_store(r_list, r_i, r_val_i + 3);
    r_list := r_updated;
    r_i := (r_i + 1);
  }
  if (l_i < l_length) {
    while (l_i < l_length)
      decreases *
    {
      assume !(r_i < r_length);
      var l_val_i: int;
      l_val_i := lst_read(l_list, l_i);
      var l_updated: int;
      l_updated := lst_store(l_list, l_i, l_val_i + 3);
      l_list := l_updated;
      l_i := (l_i + 1);
    }
  }
  if (r_i < r_length) {
    while (r_i < r_length)
      decreases *
      invariant l_i == r_i
      invariant l_list == r_list
    {
      assume !(l_i < l_length);
      r_val_i := lst_read(r_list, r_i);
      var r_updated: int;
      r_updated := lst_store(r_list, r_i, r_val_i + 3);
      r_list := r_updated;
      r_i := (r_i + 1);
    }
  }
  assert l_list == r_list;
}


Per-Task Times (ms)
-------------------
insert-elaenia-specs: 0
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 2
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 386
elaenia-invars: 1972
houdafny: 1156
repeat_range: 3519
write-dafny: 0
print-info: 0


Extraction Settings
-------------------
Max AST Depth: 1
Loop unrolling: false
Cost function: structure
Max AST Depth: 1

Elaenia completed in 3519ms
Verified: true
