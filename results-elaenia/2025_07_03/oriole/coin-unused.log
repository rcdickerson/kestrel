
Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.
Writing Daikon to /home/rob/code/kestrel/.kestrel-work/daikon_output.c...
Done
Compiling Daikon output...
Running Kvasir...
==47667== kvasir-5.8.18, C/C++ Language Front-End for Daikon with DynComp comparability analysis tool.
==47667== Copyright (C) 2007-2022, University of Washington CSE PLSE Group
==47667== Using Valgrind-3.19.0.Fjalar and LibVEX; rerun with -h for copyright info
==47667== Command: /home/rob/code/kestrel/.kestrel-work/daikon_output
==47667== 
==47668== 
==47668== For lists of detected and suppressed errors, rerun with: -s
==47668== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47669== 
==47669== For lists of detected and suppressed errors, rerun with: -s
==47669== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47670== 
==47670== For lists of detected and suppressed errors, rerun with: -s
==47670== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47671== 
==47671== For lists of detected and suppressed errors, rerun with: -s
==47671== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47672== 
==47672== For lists of detected and suppressed errors, rerun with: -s
==47672== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47673== 
==47673== For lists of detected and suppressed errors, rerun with: -s
==47673== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47674== 
==47674== For lists of detected and suppressed errors, rerun with: -s
==47674== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47675== 
==47675== For lists of detected and suppressed errors, rerun with: -s
==47675== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47676== 
==47676== For lists of detected and suppressed errors, rerun with: -s
==47676== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47677== 
==47677== For lists of detected and suppressed errors, rerun with: -s
==47677== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47678== 
==47678== For lists of detected and suppressed errors, rerun with: -s
==47678== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47679== 
==47679== For lists of detected and suppressed errors, rerun with: -s
==47679== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47680== 
==47680== For lists of detected and suppressed errors, rerun with: -s
==47680== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47681== 
==47681== For lists of detected and suppressed errors, rerun with: -s
==47681== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47682== 
==47682== For lists of detected and suppressed errors, rerun with: -s
==47682== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47683== 
==47683== For lists of detected and suppressed errors, rerun with: -s
==47683== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47684== 
==47684== For lists of detected and suppressed errors, rerun with: -s
==47684== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47685== 
==47685== For lists of detected and suppressed errors, rerun with: -s
==47685== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47686== 
==47686== For lists of detected and suppressed errors, rerun with: -s
==47686== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47687== 
==47687== For lists of detected and suppressed errors, rerun with: -s
==47687== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==47667== 
==47667== For lists of detected and suppressed errors, rerun with: -s
==47667== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Running Daikon...
houdafny.dfy(19,2): Warning: assume statement has no {:axiom} annotation
   |
19 |   assume (l_param1A == r_param1A) && ((l_param2A != r_param2A) && ((l_param1B != r_param2B) && (l_param2B == r_param2B)));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(23,2): Warning: assume statement has no {:axiom} annotation
   |
23 |   assume (l_rA == 0) || (l_rA == 1);
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(27,2): Warning: assume statement has no {:axiom} annotation
   |
27 |   assume (l_rB == 0) || (l_rB == 1);
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 1 verified, 0 errors


Aligned Product Program
-----------------------

function flip(): int

function havoc_1(l_param2B: int, r_param1A: int, l_param2A: int, r_param2A: int, r_param1B: int, l_param1A: int, l_param1B: int, r_param2B: int): int

function havoc_2(l_param2B: int, r_param1A: int, l_param2A: int, r_param2A: int, r_param1B: int, l_param1A: int, l_rA: int, l_param1B: int, r_param2B: int): int

function choice_n_3(l_param2B: int, r_param1A: int, l_param2A: int, r_param2A: int, r_param1B: int, l_param1A: int, l_rA: int, l_rB: int, l_param1B: int, r_param2B: int): int {
  l_rA
 }

function choice_n_4(l_param2B: int, r_param1A: int, l_param2A: int, r_param2A: int, r_param1B: int, l_param1A: int, l_rA: int, l_rB: int, l_param1B: int, r_rA: int, r_param2B: int): int {
  l_rB
 }

method Product(l_param1A: int, l_param2A: int, l_param1B: int, l_param2B: int, r_param1A: int, r_param2A: int, r_param1B: int, r_param2B: int)
  decreases *
{
  assume (l_param1A == r_param1A) && ((l_param2A != r_param2A) && ((l_param1B != r_param2B) && (l_param2B == r_param2B)));
  var l_rA: int;
  assert true;
  l_rA := havoc_1(l_param2B, r_param1A, l_param2A, r_param2A, r_param1B, l_param1A, l_param1B, r_param2B);
  assume (l_rA == 0) || (l_rA == 1);
  var l_rB: int;
  assert true;
  l_rB := havoc_2(l_param2B, r_param1A, l_param2A, r_param2A, r_param1B, l_param1A, l_rA, l_param1B, r_param2B);
  assume (l_rB == 0) || (l_rB == 1);
  var r_rA: int;
  var n_3: int := choice_n_3(l_param2B, r_param1A, l_param2A, r_param2A, r_param1B, l_param1A, l_rA, l_rB, l_param1B, r_param2B);
  assert (n_3 == 0) || (n_3 == 1);
  r_rA := n_3;
  var r_rB: int;
  var n_4: int := choice_n_4(l_param2B, r_param1A, l_param2A, r_param2A, r_param1B, l_param1A, l_rA, l_rB, l_param1B, r_rA, r_param2B);
  assert (n_4 == 0) || (n_4 == 1);
  r_rB := n_4;
  assert (l_rA == r_rA) || (l_rB == r_rB);
}


Per-Task Times (ms)
-------------------
insert-elaenia-specs: 0
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 0
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 391
elaenia-invars: 1869
houdafny: 1063
repeat_range: 3325
write-dafny: 0
print-info: 0


Extraction Settings
-------------------
Max AST Depth: 1
Loop unrolling: false
Cost function: structure
Max AST Depth: 1

Elaenia completed in 3325ms
Verified: true
