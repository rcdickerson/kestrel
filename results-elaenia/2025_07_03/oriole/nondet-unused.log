
Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.
Writing Daikon to /home/rob/code/kestrel/.kestrel-work/daikon_output.c...
Done
Compiling Daikon output...
Running Kvasir...
==52089== kvasir-5.8.18, C/C++ Language Front-End for Daikon with DynComp comparability analysis tool.
==52089== Copyright (C) 2007-2022, University of Washington CSE PLSE Group
==52089== Using Valgrind-3.19.0.Fjalar and LibVEX; rerun with -h for copyright info
==52089== Command: /home/rob/code/kestrel/.kestrel-work/daikon_output
==52089== 
==52090== 
==52090== For lists of detected and suppressed errors, rerun with: -s
==52090== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52091== 
==52091== For lists of detected and suppressed errors, rerun with: -s
==52091== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52092== 
==52092== For lists of detected and suppressed errors, rerun with: -s
==52092== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52093== 
==52093== For lists of detected and suppressed errors, rerun with: -s
==52093== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52094== 
==52094== For lists of detected and suppressed errors, rerun with: -s
==52094== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52095== 
==52095== For lists of detected and suppressed errors, rerun with: -s
==52095== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52096== 
==52096== For lists of detected and suppressed errors, rerun with: -s
==52096== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52097== 
==52097== For lists of detected and suppressed errors, rerun with: -s
==52097== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52098== 
==52098== For lists of detected and suppressed errors, rerun with: -s
==52098== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52099== 
==52099== For lists of detected and suppressed errors, rerun with: -s
==52099== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52100== 
==52100== For lists of detected and suppressed errors, rerun with: -s
==52100== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52101== 
==52101== For lists of detected and suppressed errors, rerun with: -s
==52101== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52102== 
==52102== For lists of detected and suppressed errors, rerun with: -s
==52102== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52103== 
==52103== For lists of detected and suppressed errors, rerun with: -s
==52103== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52104== 
==52104== For lists of detected and suppressed errors, rerun with: -s
==52104== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52105== 
==52105== For lists of detected and suppressed errors, rerun with: -s
==52105== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52106== 
==52106== For lists of detected and suppressed errors, rerun with: -s
==52106== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52107== 
==52107== For lists of detected and suppressed errors, rerun with: -s
==52107== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52108== 
==52108== For lists of detected and suppressed errors, rerun with: -s
==52108== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52109== 
==52109== For lists of detected and suppressed errors, rerun with: -s
==52109== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52089== 
==52089== For lists of detected and suppressed errors, rerun with: -s
==52089== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Running Daikon...
houdafny.dfy(19,2): Warning: assume statement has no {:axiom} annotation
   |
19 |   assume (l_param1A == r_param1A) && ((l_param2A != r_param2A) && ((l_param1B != r_param1B) && (l_param2B == r_param2B)));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(25,2): Warning: assume statement has no {:axiom} annotation
   |
25 |   assume (l_rA == 0) || (l_rA == 1);
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(56,2): Warning: assume statement has no {:axiom} annotation
   |
56 |   assume (l_rB == 0) || (l_rB == 1);
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 1 verified, 0 errors


Aligned Product Program
-----------------------

function flip(): int

function havoc_1(r_param2B: int, r_param1B: int, r_param1A: int, r_param2A: int, l_param1A: int, l_param2A: int, l_param1B: int, l_param2B: int, l_xA: int): int

function havoc_3(l_xB: int, r_param2A: int, l_param2A: int, l_param2B: int, r_param2B: int, l_xA: int, r_param1B: int, r_param1A: int, l_param1A: int, l_rA: int, l_param1B: int, r_xA: int, r_rA: int): int

function choice_n_2(r_param2B: int, r_param1B: int, r_param1A: int, r_param2A: int, l_param1A: int, l_param2A: int, l_rA: int, l_param1B: int, l_param2B: int, r_xA: int, l_xA: int): int {
  1
 }

function choice_n_4(l_xB: int, r_param2A: int, l_param2A: int, l_param2B: int, r_xB: int, l_rB: int, r_param2B: int, l_xA: int, r_param1B: int, r_param1A: int, l_param1A: int, l_rA: int, l_param1B: int, r_xA: int, r_rA: int): int {
  l_rA
 }

method Product(l_param1A: int, l_param2A: int, l_param1B: int, l_param2B: int, r_param1A: int, r_param2A: int, r_param1B: int, r_param2B: int)
  decreases *
{
  assume (l_param1A == r_param1A) && ((l_param2A != r_param2A) && ((l_param1B != r_param1B) && (l_param2B == r_param2B)));
  var l_xA: int;
  l_xA := (l_param1A + l_param2A);
  var l_rA: int;
  assert true;
  l_rA := havoc_1(r_param2B, r_param1B, r_param1A, r_param2A, l_param1A, l_param2A, l_param1B, l_param2B, l_xA);
  assume (l_rA == 0) || (l_rA == 1);
  var l_retA: int;
  var r_xA: int;
  r_xA := (r_param1A + r_param2A);
  var r_rA: int;
  var n_2: int := choice_n_2(r_param2B, r_param1B, r_param1A, r_param2A, l_param1A, l_param2A, l_rA, l_param1B, l_param2B, r_xA, l_xA);
  assert (n_2 == 0) || (n_2 == 1);
  r_rA := n_2;
  var r_retA: int;
  if ((l_rA == 0) && (r_rA == 0)) {
    l_retA := (l_xA - l_param2A);
    r_retA := (r_xA - r_param2A);
  } else {
    if ((l_rA == 0) && (!(r_rA == 0))) {
      l_retA := (l_xA - l_param2A);
      r_retA := r_param1A;
    } else {
      if ((!(l_rA == 0)) && (r_rA == 0)) {
        l_retA := l_param1A;
        r_retA := (r_xA - r_param2A);
      } else {
        l_retA := l_param1A;
        r_retA := r_param1A;
      }
    }
  }
  var l_xB: int;
  l_xB := (l_param1B + l_param2B);
  var l_rB: int;
  assert true;
  l_rB := havoc_3(l_xB, r_param2A, l_param2A, l_param2B, r_param2B, l_xA, r_param1B, r_param1A, l_param1A, l_rA, l_param1B, r_xA, r_rA);
  assume (l_rB == 0) || (l_rB == 1);
  var l_retB: int;
  var r_xB: int;
  r_xB := (r_param1B + r_param2B);
  var r_rB: int;
  var n_4: int := choice_n_4(l_xB, r_param2A, l_param2A, l_param2B, r_xB, l_rB, r_param2B, l_xA, r_param1B, r_param1A, l_param1A, l_rA, l_param1B, r_xA, r_rA);
  assert (n_4 == 0) || (n_4 == 1);
  r_rB := n_4;
  var r_retB: int;
  if ((l_rB == 0) && (r_rB == 0)) {
    l_retB := (l_xB - l_param2B);
    r_retB := (r_xB - r_param2B);
  } else {
    if ((l_rB == 0) && (!(r_rB == 0))) {
      l_retB := (l_xB - l_param2B);
      r_retB := r_param1B;
    } else {
      if ((!(l_rB == 0)) && (r_rB == 0)) {
        l_retB := l_param1B;
        r_retB := (r_xB - r_param2B);
      } else {
        l_retB := l_param1B;
        r_retB := r_param1B;
      }
    }
  }
  assert (l_retA == r_retA) || (l_retB == r_retB);
}


Per-Task Times (ms)
-------------------
insert-elaenia-specs: 0
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 9
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 413
elaenia-invars: 1872
houdafny: 1102
repeat_range: 3399
write-dafny: 0
print-info: 0


Extraction Settings
-------------------
Max AST Depth: 1
Loop unrolling: false
Cost function: structure
Max AST Depth: 1

Elaenia completed in 3399ms
Verified: true
