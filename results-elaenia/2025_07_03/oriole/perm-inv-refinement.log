
Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.
WARNING: Foralls are unsupported! Treating as true.
WARNING: Foralls are unsupported! Treating as true.
WARNING: Foralls are unsupported! Treating as true.
WARNING: Foralls are unsupported! Treating as true.
WARNING: Foralls are unsupported! Treating as true.
Writing Daikon to /home/rob/code/kestrel/.kestrel-work/daikon_output.c...
Done
Compiling Daikon output...
Running Kvasir...
==52284== kvasir-5.8.18, C/C++ Language Front-End for Daikon with DynComp comparability analysis tool.
==52284== Copyright (C) 2007-2022, University of Washington CSE PLSE Group
==52284== Using Valgrind-3.19.0.Fjalar and LibVEX; rerun with -h for copyright info
==52284== Command: /home/rob/code/kestrel/.kestrel-work/daikon_output
==52284== 
==52285== 
==52285== For lists of detected and suppressed errors, rerun with: -s
==52285== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52286== 
==52286== For lists of detected and suppressed errors, rerun with: -s
==52286== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52287== 
==52287== For lists of detected and suppressed errors, rerun with: -s
==52287== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52288== 
==52288== For lists of detected and suppressed errors, rerun with: -s
==52288== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52289== 
==52289== For lists of detected and suppressed errors, rerun with: -s
==52289== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52290== 
==52290== For lists of detected and suppressed errors, rerun with: -s
==52290== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52291== 
==52291== For lists of detected and suppressed errors, rerun with: -s
==52291== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52292== 
==52292== For lists of detected and suppressed errors, rerun with: -s
==52292== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52293== 
==52293== For lists of detected and suppressed errors, rerun with: -s
==52293== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52294== 
==52294== For lists of detected and suppressed errors, rerun with: -s
==52294== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52295== 
==52295== For lists of detected and suppressed errors, rerun with: -s
==52295== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52296== 
==52296== For lists of detected and suppressed errors, rerun with: -s
==52296== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52297== 
==52297== For lists of detected and suppressed errors, rerun with: -s
==52297== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52298== 
==52298== For lists of detected and suppressed errors, rerun with: -s
==52298== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52299== 
==52299== For lists of detected and suppressed errors, rerun with: -s
==52299== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52300== 
==52300== For lists of detected and suppressed errors, rerun with: -s
==52300== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52301== 
==52301== For lists of detected and suppressed errors, rerun with: -s
==52301== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52302== 
==52302== For lists of detected and suppressed errors, rerun with: -s
==52302== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52303== 
==52303== For lists of detected and suppressed errors, rerun with: -s
==52303== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52304== 
==52304== For lists of detected and suppressed errors, rerun with: -s
==52304== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==52284== 
==52284== For lists of detected and suppressed errors, rerun with: -s
==52284== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Running Daikon...
houdafny.dfy(21,2): Warning: assume statement has no {:axiom} annotation
   |
21 |   assume (l_list_in == r_list_in) && ((l_length == r_length) && (forall i: int, j: int, a: int, x: int :: ((!(i == j)) || (lst_read(lst_store(a, i, x), j) == x)) && forall i: int, j: int, a: int, x: int :: ((!(i != j)) || (lst_read(lst_store(a, i, x), j) == lst_read(a, j)))));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(25,2): Warning: assume statement has no {:axiom} annotation
   |
25 |   assume forall val: int :: (lst_contains(l_list_in, val) == lst_contains(l_list, val)) && forall i: int, j: int :: ((!(i < j)) || (lst_read(l_list, i) <= lst_read(l_list, j)));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(56,6): Warning: assume statement has no {:axiom} annotation
   |
56 |       assume !(r_i < r_length);
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(69,6): Warning: assume statement has no {:axiom} annotation
   |
69 |       assume !(l_i < l_length);
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 1 verified, 0 errors


Aligned Product Program
-----------------------

function lst_contains(list: int, value: int): int

function lst_read(list: int, index: int): int

function lst_store(list: int, index: int, value: int): int

function shuffle(list: int): int

function sort(list: int): int

function havoc_1(l_length: int, r_length: int): int

function choice_n_2(l_list: int, l_length: int, l_i: int, r_length: int, l_sum: int): int {
  l_list
 }

method Product(l_list_in: int, l_length: int, r_list_in: int, r_length: int)
  decreases *
{
  assume (l_list_in == r_list_in) && ((l_length == r_length) && (forall i: int, j: int, a: int, x: int :: ((!(i == j)) || (lst_read(lst_store(a, i, x), j) == x)) && forall i: int, j: int, a: int, x: int :: ((!(i != j)) || (lst_read(lst_store(a, i, x), j) == lst_read(a, j)))));
  var l_list: int;
  assert true;
  l_list := havoc_1(l_length, r_length);
  assume forall val: int :: (lst_contains(l_list_in, val) == lst_contains(l_list, val)) && forall i: int, j: int :: ((!(i < j)) || (lst_read(l_list, i) <= lst_read(l_list, j)));
  var l_sum: int;
  l_sum := 0;
  var l_i: int;
  l_i := 0;
  var r_list: int;
  var n_2: int := choice_n_2(l_list, l_length, l_i, r_length, l_sum);
  assert forall val: int :: (lst_contains(r_list_in, val) == lst_contains(n_2, val));
  r_list := n_2;
  var r_sum: int;
  r_sum := 0;
  var r_i: int;
  r_i := 0;
  while ((l_i < l_length) && (r_i < r_length))
    decreases *
    invariant l_sum == r_sum
    invariant l_i == r_i
  {
    var l_val: int;
    l_val := lst_read(l_list, l_i);
    l_sum := (l_sum + l_val);
    l_i := (l_i + 1);
    var r_val: int;
    r_val := lst_read(r_list, r_i);
    r_sum := (r_sum + r_val);
    r_i := (r_i + 1);
  }
  if (l_i < l_length) {
    while (l_i < l_length)
      decreases *
    {
      assume !(r_i < r_length);
      var l_val: int;
      l_val := lst_read(l_list, l_i);
      l_sum := (l_sum + l_val);
      l_i := (l_i + 1);
    }
  }
  if (r_i < r_length) {
    while (r_i < r_length)
      decreases *
      invariant l_sum == r_sum
      invariant l_i == r_i
    {
      assume !(l_i < l_length);
      var r_val: int;
      r_val := lst_read(r_list, r_i);
      r_sum := (r_sum + r_val);
      r_i := (r_i + 1);
    }
  }
  assert l_sum == r_sum;
}


Per-Task Times (ms)
-------------------
insert-elaenia-specs: 0
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 2
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 354
elaenia-invars: 1936
houdafny: 1144
repeat_range: 3438
write-dafny: 0
print-info: 0


Extraction Settings
-------------------
Max AST Depth: 1
Loop unrolling: false
Cost function: structure
Max AST Depth: 1

Elaenia completed in 3439ms
Verified: true
