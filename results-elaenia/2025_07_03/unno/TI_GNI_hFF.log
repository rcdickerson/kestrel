
Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.
Writing Daikon to /home/rob/code/kestrel/.kestrel-work/daikon_output.c...
Done
Compiling Daikon output...
Running Kvasir...
==53689== kvasir-5.8.18, C/C++ Language Front-End for Daikon with DynComp comparability analysis tool.
==53689== Copyright (C) 2007-2022, University of Washington CSE PLSE Group
==53689== Using Valgrind-3.19.0.Fjalar and LibVEX; rerun with -h for copyright info
==53689== Command: /home/rob/code/kestrel/.kestrel-work/daikon_output
==53689== 
==53690== 
==53690== For lists of detected and suppressed errors, rerun with: -s
==53690== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53691== 
==53691== For lists of detected and suppressed errors, rerun with: -s
==53691== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53692== 
==53692== For lists of detected and suppressed errors, rerun with: -s
==53692== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53693== 
==53693== For lists of detected and suppressed errors, rerun with: -s
==53693== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53694== 
==53694== For lists of detected and suppressed errors, rerun with: -s
==53694== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53695== 
==53695== For lists of detected and suppressed errors, rerun with: -s
==53695== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53696== 
==53696== For lists of detected and suppressed errors, rerun with: -s
==53696== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53697== 
==53697== For lists of detected and suppressed errors, rerun with: -s
==53697== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53698== 
==53698== For lists of detected and suppressed errors, rerun with: -s
==53698== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53699== 
==53699== For lists of detected and suppressed errors, rerun with: -s
==53699== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53700== 
==53700== For lists of detected and suppressed errors, rerun with: -s
==53700== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53701== 
==53701== For lists of detected and suppressed errors, rerun with: -s
==53701== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53702== 
==53702== For lists of detected and suppressed errors, rerun with: -s
==53702== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53703== 
==53703== For lists of detected and suppressed errors, rerun with: -s
==53703== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53704== 
==53704== For lists of detected and suppressed errors, rerun with: -s
==53704== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53705== 
==53705== For lists of detected and suppressed errors, rerun with: -s
==53705== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53706== 
==53706== For lists of detected and suppressed errors, rerun with: -s
==53706== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53707== 
==53707== For lists of detected and suppressed errors, rerun with: -s
==53707== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53708== 
==53708== For lists of detected and suppressed errors, rerun with: -s
==53708== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53709== 
==53709== For lists of detected and suppressed errors, rerun with: -s
==53709== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==53689== 
==53689== For lists of detected and suppressed errors, rerun with: -s
==53689== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Running Daikon...
houdafny.dfy(49,2): Warning: assume statement has no {:axiom} annotation
   |
49 |   assume (l_low == r_low) && ((l_high == 0) && (r_high == 0));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(63,4): Warning: assume statement has no {:axiom} annotation
   |
63 |     assume true;
   |     ^^^^^^^^^^^^

houdafny.dfy(88,6): Warning: assume statement has no {:axiom} annotation
   |
88 |       assume true;
   |       ^^^^^^^^^^^^

houdafny.dfy(116,8): Warning: assume statement has no {:axiom} annotation
    |
116 |         assume (l_r == 0) || (l_r == 1);
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(126,12): Warning: assume statement has no {:axiom} annotation
    |
126 |             assume (l_r == 0) || (l_r == 1);
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(142,8): Warning: assume statement has no {:axiom} annotation
    |
142 |         assume (l_r == 0) || (l_r == 1);
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(155,10): Warning: assume statement has no {:axiom} annotation
    |
155 |           assume (l_r == 0) || (l_r == 1);
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(167,12): Warning: assume statement has no {:axiom} annotation
    |
167 |             assume !(r_r != 0);
    |             ^^^^^^^^^^^^^^^^^^^

houdafny.dfy(171,12): Warning: assume statement has no {:axiom} annotation
    |
171 |             assume (l_r == 0) || (l_r == 1);
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(180,12): Warning: assume statement has no {:axiom} annotation
    |
180 |             assume !(l_r != 0);
    |             ^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 1 verified, 0 errors


Aligned Product Program
-----------------------

function arb_bool(): int

function arb_int(): int

function havoc_1(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int

function havoc_3(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int

function havoc_6(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int

function havoc_7(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int

function havoc_9(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int

function havoc_11(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int

function havoc_13(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int

function choice_n_12(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int

function choice_n_14(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int {
  l_r
 }

function choice_n_4(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int {
  0
 }

function choice_n_2(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int {
  0
 }

function choice_n_5(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int {
  r_low
 }

function choice_n_8(r_low: int, l_x: int, l_ret: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int {
  0
 }

function choice_n_10(r_low: int, l_x: int, r_x: int, r_high: int, l_r: int, l_low: int, r_r: int, l_high: int): int {
  l_r
 }

method Product(l_low: int, l_high: int, r_low: int, r_high: int)
  decreases *
{
  assume (l_low == r_low) && ((l_high == 0) && (r_high == 0));
  var l_x: int;
  l_x := 0;
  var l_r: int;
  l_r := 0;
  var l_ret: int;
  var r_x: int;
  r_x := 0;
  var r_r: int;
  r_r := 0;
  var r_ret: int;
  if ((l_high != 0) && (r_high != 0)) {
    assert true;
    l_x := havoc_1(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
    assume true;
    var n_2: int := choice_n_2(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
    assert true;
    r_x := n_2;
    if ((l_x >= l_low) && (r_x >= r_low)) {
      l_ret := l_x;
      r_ret := r_x;
    } else {
      if ((l_x >= l_low) && (!(r_x >= r_low))) {
        l_ret := l_x;
        r_ret := r_low;
      } else {
        if ((!(l_x >= l_low)) && (r_x >= r_low)) {
          l_ret := l_low;
          r_ret := r_x;
        } else {
          l_ret := l_low;
          r_ret := r_low;
        }
      }
    }
  } else {
    if ((l_high != 0) && (!(r_high != 0))) {
      assert true;
      l_x := havoc_3(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
      assume true;
      if (l_x >= l_low) {
        l_ret := l_x;
      } else {
        l_ret := l_low;
      }
      r_x := r_low;
      var n_4: int := choice_n_4(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
      assert (n_4 == 0) || (n_4 == 1);
      r_r := n_4;
      if (r_r != 0) {
        while (r_r != 0)
          decreases *
          invariant l_r == r_r
          invariant l_x == r_x
        {
          r_x := (r_x + 1);
          var n_5: int := choice_n_5(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
          assert (n_5 == 0) || (n_5 == 1);
          r_r := n_5;
        }
      }
      r_ret := r_x;
    } else {
      if ((!(l_high != 0)) && (r_high != 0)) {
        l_x := l_low;
        assert true;
        l_r := havoc_6(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
        assume (l_r == 0) || (l_r == 1);
        if (l_r != 0) {
          while (l_r != 0)
            decreases *
            invariant l_r == r_r
            invariant l_x == r_x
          {
            l_x := (l_x + 1);
            assert true;
            l_r := havoc_7(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
            assume (l_r == 0) || (l_r == 1);
          }
        }
        l_ret := l_x;
        var n_8: int := choice_n_8(r_low, l_x, l_ret, r_x, r_high, l_r, l_low, r_r, l_high);
        assert true;
        r_x := n_8;
        if (r_x >= r_low) {
          r_ret := r_x;
        } else {
          r_ret := r_low;
        }
      } else {
        l_x := l_low;
        assert true;
        l_r := havoc_9(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
        assume (l_r == 0) || (l_r == 1);
        r_x := r_low;
        var n_10: int := choice_n_10(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
        assert (n_10 == 0) || (n_10 == 1);
        r_r := n_10;
        while ((l_r != 0) && (r_r != 0))
          decreases *
          invariant l_r == r_r
          invariant l_x == r_x
        {
          l_x := (l_x + 1);
          assert true;
          l_r := havoc_13(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
          assume (l_r == 0) || (l_r == 1);
          r_x := (r_x + 1);
          var n_14: int := choice_n_14(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
          assert (n_14 == 0) || (n_14 == 1);
          r_r := n_14;
        }
        if (l_r != 0) {
          while (l_r != 0)
            decreases *
            invariant l_r == r_r
            invariant l_x == r_x
          {
            assume !(r_r != 0);
            l_x := (l_x + 1);
            assert true;
            l_r := havoc_11(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
            assume (l_r == 0) || (l_r == 1);
          }
        }
        if (r_r != 0) {
          while (r_r != 0)
            decreases *
            invariant l_r == r_r
            invariant l_x == r_x
          {
            assume !(l_r != 0);
            r_x := (r_x + 1);
            var n_12: int := choice_n_12(r_low, l_x, r_x, r_high, l_r, l_low, r_r, l_high);
            assert (n_12 == 0) || (n_12 == 1);
            r_r := n_12;
          }
        }
        l_ret := l_x;
        r_ret := r_x;
      }
    }
  }
  assert l_ret == r_ret;
}


Per-Task Times (ms)
-------------------
insert-elaenia-specs: 0
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 19
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 1
solve-sketch: 583
elaenia-invars: 2108
houdafny: 1145
repeat_range: 3857
write-dafny: 0
print-info: 0


Extraction Settings
-------------------
Max AST Depth: 1
Loop unrolling: false
Cost function: structure
Max AST Depth: 1

Elaenia completed in 3858ms
Verified: true
