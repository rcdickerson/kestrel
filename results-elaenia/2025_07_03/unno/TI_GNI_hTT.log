
Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_structure
Computed alignment by local loop counting.
Writing Daikon to /home/rob/code/kestrel/.kestrel-work/daikon_output.c...
Done
Compiling Daikon output...
Running Kvasir...
==54109== kvasir-5.8.18, C/C++ Language Front-End for Daikon with DynComp comparability analysis tool.
==54109== Copyright (C) 2007-2022, University of Washington CSE PLSE Group
==54109== Using Valgrind-3.19.0.Fjalar and LibVEX; rerun with -h for copyright info
==54109== Command: /home/rob/code/kestrel/.kestrel-work/daikon_output
==54109== 
==54110== 
==54110== For lists of detected and suppressed errors, rerun with: -s
==54110== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54111== 
==54111== For lists of detected and suppressed errors, rerun with: -s
==54111== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54112== 
==54112== For lists of detected and suppressed errors, rerun with: -s
==54112== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54113== 
==54113== For lists of detected and suppressed errors, rerun with: -s
==54113== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54114== 
==54114== For lists of detected and suppressed errors, rerun with: -s
==54114== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54115== 
==54115== For lists of detected and suppressed errors, rerun with: -s
==54115== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54116== 
==54116== For lists of detected and suppressed errors, rerun with: -s
==54116== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54117== 
==54117== For lists of detected and suppressed errors, rerun with: -s
==54117== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54118== 
==54118== For lists of detected and suppressed errors, rerun with: -s
==54118== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54119== 
==54119== For lists of detected and suppressed errors, rerun with: -s
==54119== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54120== 
==54120== For lists of detected and suppressed errors, rerun with: -s
==54120== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54121== 
==54121== For lists of detected and suppressed errors, rerun with: -s
==54121== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54122== 
==54122== For lists of detected and suppressed errors, rerun with: -s
==54122== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54123== 
==54123== For lists of detected and suppressed errors, rerun with: -s
==54123== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54124== 
==54124== For lists of detected and suppressed errors, rerun with: -s
==54124== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54125== 
==54125== For lists of detected and suppressed errors, rerun with: -s
==54125== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54126== 
==54126== For lists of detected and suppressed errors, rerun with: -s
==54126== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54127== 
==54127== For lists of detected and suppressed errors, rerun with: -s
==54127== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54128== 
==54128== For lists of detected and suppressed errors, rerun with: -s
==54128== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54129== 
==54129== For lists of detected and suppressed errors, rerun with: -s
==54129== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==54109== 
==54109== For lists of detected and suppressed errors, rerun with: -s
==54109== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Running Daikon...
houdafny.dfy(49,2): Warning: assume statement has no {:axiom} annotation
   |
49 |   assume (l_low == r_low) && ((l_high != 0) && (r_high != 0));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(57,4): Warning: assume statement has no {:axiom} annotation
   |
57 |     assume true;
   |     ^^^^^^^^^^^^

houdafny.dfy(82,6): Warning: assume statement has no {:axiom} annotation
   |
82 |       assume true;
   |       ^^^^^^^^^^^^

houdafny.dfy(110,8): Warning: assume statement has no {:axiom} annotation
    |
110 |         assume (l_r == 0) || (l_r == 1);
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(118,12): Warning: assume statement has no {:axiom} annotation
    |
118 |             assume (l_r == 0) || (l_r == 1);
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(135,8): Warning: assume statement has no {:axiom} annotation
    |
135 |         assume (l_r == 0) || (l_r == 1);
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(147,10): Warning: assume statement has no {:axiom} annotation
    |
147 |           assume (l_r == 0) || (l_r == 1);
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(157,12): Warning: assume statement has no {:axiom} annotation
    |
157 |             assume !(r_r != 0);
    |             ^^^^^^^^^^^^^^^^^^^

houdafny.dfy(161,12): Warning: assume statement has no {:axiom} annotation
    |
161 |             assume (l_r == 0) || (l_r == 1);
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(168,12): Warning: assume statement has no {:axiom} annotation
    |
168 |             assume !(l_r != 0);
    |             ^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 1 verified, 0 errors


Aligned Product Program
-----------------------

function arb_bool(): int

function arb_int(): int

function havoc_1(r_low: int, r_high: int, l_high: int, l_low: int): int

function havoc_3(r_low: int, r_high: int, l_high: int, l_low: int): int

function havoc_6(l_x: int, r_low: int, r_high: int, l_high: int, l_low: int): int

function havoc_7(l_x: int, r_low: int, r_high: int, l_r: int, l_high: int, l_low: int): int

function havoc_9(l_x: int, r_low: int, r_high: int, l_high: int, l_low: int): int

function havoc_11(l_x: int, r_low: int, r_high: int, r_x: int, l_r: int, l_high: int, r_r: int, l_low: int): int

function havoc_13(l_x: int, r_low: int, r_high: int, r_x: int, l_r: int, l_high: int, r_r: int, l_low: int): int

function choice_n_12(l_x: int, r_low: int, r_high: int, r_x: int, l_r: int, l_high: int, r_r: int, l_low: int): int

function choice_n_4(l_x: int, r_low: int, r_high: int, r_x: int, l_high: int, l_low: int): int {
  0
 }

function choice_n_5(l_x: int, r_low: int, r_high: int, r_x: int, l_high: int, r_r: int, l_low: int): int {
  0
 }

function choice_n_2(l_x: int, r_low: int, r_high: int, l_high: int, l_low: int): int {
  l_x
 }

function choice_n_8(l_x: int, r_low: int, l_ret: int, r_high: int, l_r: int, l_high: int, l_low: int): int {
  0
 }

function choice_n_10(l_x: int, r_low: int, r_high: int, r_x: int, l_r: int, l_high: int, l_low: int): int {
  0
 }

function choice_n_14(l_x: int, r_low: int, r_high: int, r_x: int, l_r: int, l_high: int, r_r: int, l_low: int): int {
  0
 }

method Product(l_low: int, l_high: int, r_low: int, r_high: int)
  decreases *
{
  assume (l_low == r_low) && ((l_high != 0) && (r_high != 0));
  var l_x: int;
  var l_ret: int;
  var r_x: int;
  var r_ret: int;
  if ((l_high != 0) && (r_high != 0)) {
    assert true;
    l_x := havoc_1(r_low, r_high, l_high, l_low);
    assume true;
    var n_2: int := choice_n_2(l_x, r_low, r_high, l_high, l_low);
    assert true;
    r_x := n_2;
    if ((l_x >= l_low) && (r_x >= r_low)) {
      l_ret := l_x;
      r_ret := r_x;
    } else {
      if ((l_x >= l_low) && (!(r_x >= r_low))) {
        l_ret := l_x;
        r_ret := r_low;
      } else {
        if ((!(l_x >= l_low)) && (r_x >= r_low)) {
          l_ret := l_low;
          r_ret := r_x;
        } else {
          l_ret := l_low;
          r_ret := r_low;
        }
      }
    }
  } else {
    if ((l_high != 0) && (!(r_high != 0))) {
      assert true;
      l_x := havoc_3(r_low, r_high, l_high, l_low);
      assume true;
      if (l_x >= l_low) {
        l_ret := l_x;
      } else {
        l_ret := l_low;
      }
      r_x := r_low;
      var r_r: int;
      var n_4: int := choice_n_4(l_x, r_low, r_high, r_x, l_high, l_low);
      assert (n_4 == 0) || (n_4 == 1);
      r_r := n_4;
      if (r_r != 0) {
        while (r_r != 0)
          decreases *
        {
          r_x := (r_x + 1);
          var n_5: int := choice_n_5(l_x, r_low, r_high, r_x, l_high, r_r, l_low);
          assert (n_5 == 0) || (n_5 == 1);
          r_r := n_5;
        }
      }
      r_ret := r_x;
    } else {
      if ((!(l_high != 0)) && (r_high != 0)) {
        l_x := l_low;
        var l_r: int;
        assert true;
        l_r := havoc_6(l_x, r_low, r_high, l_high, l_low);
        assume (l_r == 0) || (l_r == 1);
        if (l_r != 0) {
          while (l_r != 0)
            decreases *
          {
            l_x := (l_x + 1);
            assert true;
            l_r := havoc_7(l_x, r_low, r_high, l_r, l_high, l_low);
            assume (l_r == 0) || (l_r == 1);
          }
        }
        l_ret := l_x;
        var n_8: int := choice_n_8(l_x, r_low, l_ret, r_high, l_r, l_high, l_low);
        assert true;
        r_x := n_8;
        if (r_x >= r_low) {
          r_ret := r_x;
        } else {
          r_ret := r_low;
        }
      } else {
        l_x := l_low;
        var l_r: int;
        assert true;
        l_r := havoc_9(l_x, r_low, r_high, l_high, l_low);
        assume (l_r == 0) || (l_r == 1);
        r_x := r_low;
        var r_r: int;
        var n_10: int := choice_n_10(l_x, r_low, r_high, r_x, l_r, l_high, l_low);
        assert (n_10 == 0) || (n_10 == 1);
        r_r := n_10;
        while ((l_r != 0) && (r_r != 0))
          decreases *
        {
          l_x := (l_x + 1);
          assert true;
          l_r := havoc_13(l_x, r_low, r_high, r_x, l_r, l_high, r_r, l_low);
          assume (l_r == 0) || (l_r == 1);
          r_x := (r_x + 1);
          var n_14: int := choice_n_14(l_x, r_low, r_high, r_x, l_r, l_high, r_r, l_low);
          assert (n_14 == 0) || (n_14 == 1);
          r_r := n_14;
        }
        if (l_r != 0) {
          while (l_r != 0)
            decreases *
          {
            assume !(r_r != 0);
            l_x := (l_x + 1);
            assert true;
            l_r := havoc_11(l_x, r_low, r_high, r_x, l_r, l_high, r_r, l_low);
            assume (l_r == 0) || (l_r == 1);
          }
        }
        if (r_r != 0) {
          while (r_r != 0)
            decreases *
          {
            assume !(l_r != 0);
            r_x := (r_x + 1);
            var n_12: int := choice_n_12(l_x, r_low, r_high, r_x, l_r, l_high, r_r, l_low);
            assert (n_12 == 0) || (n_12 == 1);
            r_r := n_12;
          }
        }
        l_ret := l_x;
        r_ret := r_x;
      }
    }
  }
  assert l_ret == r_ret;
}


Per-Task Times (ms)
-------------------
insert-elaenia-specs: 0
set-parameters: 0
print-info: 0
elaenia-syntactic-alignment: 18
aligned-crel: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 526
elaenia-invars: 2038
houdafny: 1207
repeat_range: 3793
write-dafny: 0
print-info: 0


Extraction Settings
-------------------
Max AST Depth: 1
Loop unrolling: false
Cost function: structure
Max AST Depth: 1

Elaenia completed in 3794ms
Verified: true
