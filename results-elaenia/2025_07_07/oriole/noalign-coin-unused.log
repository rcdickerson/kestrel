
Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_structure
Treating naive product as final alignment.
Writing Daikon to /home/rob/code/kestrel/.kestrel-work/daikon_output.c...
Done
Compiling Daikon output...
Running Kvasir...
==318296== kvasir-5.8.18, C/C++ Language Front-End for Daikon with DynComp comparability analysis tool.
==318296== Copyright (C) 2007-2022, University of Washington CSE PLSE Group
==318296== Using Valgrind-3.19.0.Fjalar and LibVEX; rerun with -h for copyright info
==318296== Command: /home/rob/code/kestrel/.kestrel-work/daikon_output
==318296== 
==318298== 
==318298== For lists of detected and suppressed errors, rerun with: -s
==318298== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318299== 
==318299== For lists of detected and suppressed errors, rerun with: -s
==318299== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318302== 
==318302== For lists of detected and suppressed errors, rerun with: -s
==318302== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318303== 
==318303== For lists of detected and suppressed errors, rerun with: -s
==318303== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318304== 
==318304== For lists of detected and suppressed errors, rerun with: -s
==318304== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318305== 
==318305== For lists of detected and suppressed errors, rerun with: -s
==318305== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318306== 
==318306== For lists of detected and suppressed errors, rerun with: -s
==318306== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318307== 
==318307== For lists of detected and suppressed errors, rerun with: -s
==318307== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318308== 
==318308== For lists of detected and suppressed errors, rerun with: -s
==318308== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318309== 
==318309== For lists of detected and suppressed errors, rerun with: -s
==318309== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318310== 
==318310== For lists of detected and suppressed errors, rerun with: -s
==318310== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318311== 
==318311== For lists of detected and suppressed errors, rerun with: -s
==318311== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318312== 
==318312== For lists of detected and suppressed errors, rerun with: -s
==318312== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318313== 
==318313== For lists of detected and suppressed errors, rerun with: -s
==318313== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318314== 
==318314== For lists of detected and suppressed errors, rerun with: -s
==318314== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318321== 
==318321== For lists of detected and suppressed errors, rerun with: -s
==318321== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318322== 
==318322== For lists of detected and suppressed errors, rerun with: -s
==318322== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318323== 
==318323== For lists of detected and suppressed errors, rerun with: -s
==318323== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318324== 
==318324== For lists of detected and suppressed errors, rerun with: -s
==318324== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318325== 
==318325== For lists of detected and suppressed errors, rerun with: -s
==318325== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==318296== 
==318296== For lists of detected and suppressed errors, rerun with: -s
==318296== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Running Daikon...
houdafny.dfy(19,2): Warning: assume statement has no {:axiom} annotation
   |
19 |   assume (l_param1A == r_param1A) && ((l_param2A != r_param2A) && ((l_param1B != r_param2B) && (l_param2B == r_param2B)));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(23,2): Warning: assume statement has no {:axiom} annotation
   |
23 |   assume (l_rA == 0) || (l_rA == 1);
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(27,2): Warning: assume statement has no {:axiom} annotation
   |
27 |   assume (l_rB == 0) || (l_rB == 1);
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 1 verified, 0 errors


Aligned Product Program
-----------------------

function flip(): int

function havoc_1(l_param1A: int, r_param1B: int, l_param2B: int, r_param1A: int, r_param2B: int, l_param1B: int, l_param2A: int, r_param2A: int): int

function havoc_2(l_param1A: int, r_param1B: int, l_param2B: int, r_param1A: int, r_param2B: int, l_rA: int, l_param1B: int, l_param2A: int, r_param2A: int): int

function choice_n_3(l_param1A: int, r_param1B: int, l_param2B: int, r_param1A: int, r_param2B: int, l_rA: int, l_rB: int, l_param1B: int, l_param2A: int, r_param2A: int): int {
  l_rA
 }

function choice_n_4(l_param1A: int, r_param1B: int, l_param2B: int, r_param1A: int, r_param2B: int, l_rA: int, l_rB: int, l_param1B: int, l_param2A: int, r_param2A: int): int {
  0
 }

method Product(l_param1A: int, l_param2A: int, l_param1B: int, l_param2B: int, r_param1A: int, r_param2A: int, r_param1B: int, r_param2B: int)
  decreases *
{
  assume (l_param1A == r_param1A) && ((l_param2A != r_param2A) && ((l_param1B != r_param2B) && (l_param2B == r_param2B)));
  var l_rA: int;
  assert true;
  l_rA := havoc_1(l_param1A, r_param1B, l_param2B, r_param1A, r_param2B, l_param1B, l_param2A, r_param2A);
  assume (l_rA == 0) || (l_rA == 1);
  var l_rB: int;
  assert true;
  l_rB := havoc_2(l_param1A, r_param1B, l_param2B, r_param1A, r_param2B, l_rA, l_param1B, l_param2A, r_param2A);
  assume (l_rB == 0) || (l_rB == 1);
  var r_rA: int;
  var n_3: int := choice_n_3(l_param1A, r_param1B, l_param2B, r_param1A, r_param2B, l_rA, l_rB, l_param1B, l_param2A, r_param2A);
  assert (n_3 == 0) || (n_3 == 1);
  r_rA := n_3;
  var r_rB: int;
  var n_4: int := choice_n_4(l_param1A, r_param1B, l_param2B, r_param1A, r_param2B, l_rA, l_rB, l_param1B, l_param2A, r_param2A);
  assert (n_4 == 0) || (n_4 == 1);
  r_rB := n_4;
  assert (l_rA == r_rA) || (l_rB == r_rB);
}


Per-Task Times (ms)
-------------------
insert-elaenia-specs: 0
set-parameters: 0
print-info: 0
align-none: 0
aligned-crel: 0
print-info: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 438
elaenia-invars: 2301
houdafny: 1306
compound_task: 4047
repeat_range: 4047
write-dafny: 0
print-info: 0


Extraction Settings
-------------------
Max AST Depth: 1
Loop unrolling: false
Cost function: structure
Max AST Depth: 1

Elaenia completed in 4047ms
Verified: true
