
Beginning Iteration
-------------------
add_unrolls: false
depth: 1
cost function: optimize_structure
Treating naive product as final alignment.
Writing Daikon to /home/rob/code/kestrel/.kestrel-work/daikon_output.c...
Done
Compiling Daikon output...
Running Kvasir...
==329204== kvasir-5.8.18, C/C++ Language Front-End for Daikon with DynComp comparability analysis tool.
==329204== Copyright (C) 2007-2022, University of Washington CSE PLSE Group
==329204== Using Valgrind-3.19.0.Fjalar and LibVEX; rerun with -h for copyright info
==329204== Command: /home/rob/code/kestrel/.kestrel-work/daikon_output
==329204== 
==329205== 
==329205== For lists of detected and suppressed errors, rerun with: -s
==329205== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329206== 
==329206== For lists of detected and suppressed errors, rerun with: -s
==329206== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329215== 
==329215== For lists of detected and suppressed errors, rerun with: -s
==329215== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329216== 
==329216== For lists of detected and suppressed errors, rerun with: -s
==329216== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329217== 
==329217== For lists of detected and suppressed errors, rerun with: -s
==329217== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329218== 
==329218== For lists of detected and suppressed errors, rerun with: -s
==329218== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329219== 
==329219== For lists of detected and suppressed errors, rerun with: -s
==329219== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329220== 
==329220== For lists of detected and suppressed errors, rerun with: -s
==329220== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329221== 
==329221== For lists of detected and suppressed errors, rerun with: -s
==329221== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329222== 
==329222== For lists of detected and suppressed errors, rerun with: -s
==329222== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329223== 
==329223== For lists of detected and suppressed errors, rerun with: -s
==329223== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329224== 
==329224== For lists of detected and suppressed errors, rerun with: -s
==329224== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329225== 
==329225== For lists of detected and suppressed errors, rerun with: -s
==329225== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329226== 
==329226== For lists of detected and suppressed errors, rerun with: -s
==329226== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329227== 
==329227== For lists of detected and suppressed errors, rerun with: -s
==329227== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329228== 
==329228== For lists of detected and suppressed errors, rerun with: -s
==329228== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329229== 
==329229== For lists of detected and suppressed errors, rerun with: -s
==329229== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329230== 
==329230== For lists of detected and suppressed errors, rerun with: -s
==329230== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329231== 
==329231== For lists of detected and suppressed errors, rerun with: -s
==329231== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329232== 
==329232== For lists of detected and suppressed errors, rerun with: -s
==329232== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
==329204== 
==329204== For lists of detected and suppressed errors, rerun with: -s
==329204== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Running Daikon...
houdafny.dfy(19,2): Warning: assume statement has no {:axiom} annotation
   |
19 |   assume (l_param1A == r_param1A) && ((l_param2A != r_param2A) && ((l_param1B != r_param1B) && (l_param2B == r_param2B)));
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(25,2): Warning: assume statement has no {:axiom} annotation
   |
25 |   assume (l_rA == 0) || (l_rA == 1);
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

houdafny.dfy(37,2): Warning: assume statement has no {:axiom} annotation
   |
37 |   assume (l_rB == 0) || (l_rB == 1);
   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Dafny program verifier finished with 1 verified, 0 errors


Aligned Product Program
-----------------------

function flip(): int

function havoc_1(l_param2A: int, l_param1A: int, r_param2A: int, l_param1B: int, r_param1B: int, r_param1A: int, r_param2B: int, l_xA: int, l_param2B: int): int

function havoc_2(l_rA: int, l_param2A: int, l_xB: int, l_param1A: int, r_param2A: int, l_param1B: int, r_param1B: int, r_param1A: int, r_param2B: int, l_xA: int, l_param2B: int): int

function choice_n_3(l_param2A: int, l_param1B: int, l_rB: int, l_xA: int, r_xA: int, l_rA: int, l_param2B: int, l_param1A: int, r_param2A: int, l_xB: int, r_param1B: int, r_param1A: int, r_param2B: int): int {
  0
 }

function choice_n_4(l_param2A: int, l_param1B: int, l_rB: int, l_xA: int, r_xA: int, l_rA: int, l_param2B: int, r_xB: int, l_param1A: int, r_param2A: int, l_xB: int, r_param1B: int, r_param1A: int, r_param2B: int): int {
  0
 }

method Product(l_param1A: int, l_param2A: int, l_param1B: int, l_param2B: int, r_param1A: int, r_param2A: int, r_param1B: int, r_param2B: int)
  decreases *
{
  assume (l_param1A == r_param1A) && ((l_param2A != r_param2A) && ((l_param1B != r_param1B) && (l_param2B == r_param2B)));
  var l_xA: int;
  l_xA := (l_param1A + l_param2A);
  var l_rA: int;
  assert true;
  l_rA := havoc_1(l_param2A, l_param1A, r_param2A, l_param1B, r_param1B, r_param1A, r_param2B, l_xA, l_param2B);
  assume (l_rA == 0) || (l_rA == 1);
  var l_retA: int;
  if (l_rA == 0) {
    l_retA := (l_xA - l_param2A);
  } else {
    l_retA := l_param1A;
  }
  var l_xB: int;
  l_xB := (l_param1B + l_param2B);
  var l_rB: int;
  assert true;
  l_rB := havoc_2(l_rA, l_param2A, l_xB, l_param1A, r_param2A, l_param1B, r_param1B, r_param1A, r_param2B, l_xA, l_param2B);
  assume (l_rB == 0) || (l_rB == 1);
  var l_retB: int;
  if (l_rB == 0) {
    l_retB := (l_xB - l_param2B);
  } else {
    l_retB := l_param1B;
  }
  var r_xA: int;
  r_xA := (r_param1A + r_param2A);
  var r_rA: int;
  var n_3: int := choice_n_3(l_param2A, l_param1B, l_rB, l_xA, r_xA, l_rA, l_param2B, l_param1A, r_param2A, l_xB, r_param1B, r_param1A, r_param2B);
  assert (n_3 == 0) || (n_3 == 1);
  r_rA := n_3;
  var r_retA: int;
  if (r_rA == 0) {
    r_retA := (r_xA - r_param2A);
  } else {
    r_retA := r_param1A;
  }
  var r_xB: int;
  r_xB := (r_param1B + r_param2B);
  var r_rB: int;
  var n_4: int := choice_n_4(l_param2A, l_param1B, l_rB, l_xA, r_xA, l_rA, l_param2B, r_xB, l_param1A, r_param2A, l_xB, r_param1B, r_param1A, r_param2B);
  assert (n_4 == 0) || (n_4 == 1);
  r_rB := n_4;
  var r_retB: int;
  if (r_rB == 0) {
    r_retB := (r_xB - r_param2B);
  } else {
    r_retB := r_param1B;
  }
  assert (l_retA == r_retA) || (l_retB == r_retB);
}


Per-Task Times (ms)
-------------------
insert-elaenia-specs: 0
set-parameters: 0
print-info: 0
align-none: 0
aligned-crel: 0
print-info: 0
print-info: 0
print-info: 0
insert-elaenia-specs: 0
write-sketch: 0
solve-sketch: 417
elaenia-invars: 1897
houdafny: 1077
compound_task: 3393
repeat_range: 3394
write-dafny: 0
print-info: 0


Extraction Settings
-------------------
Max AST Depth: 1
Loop unrolling: false
Cost function: structure
Max AST Depth: 1

Elaenia completed in 3394ms
Verified: true
